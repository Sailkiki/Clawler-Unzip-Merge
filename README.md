# 使用



**注意使用程序的时候一定要修改自己的路径**



## 第一步：爬取信息

① ： 使用**Clawler.py**这个程序， 我用的是pycharm， 在terminal下先安装必要的包 **pip install requests==2.26.0**,  **pip install lxml**。

②： 在程序里定义的 "url" 变量需要根据不同的模块进行修改， 文物类型有四种,  每一种的链接都不一样， 我的是第三类陶瓷器， 链接是这样的

![img](file:///C:\Users\1\AppData\Roaming\Tencent\Users\1025935864\QQ\WinTemp\RichOle\(Q2KWOIJJL3`]OOC)E@RSS8.png)

最后url为这个链接除最后面的数字的全部内容， 因为 No=  后面的数字代表你这个类型的所在页数，他是个变量。

**head里面的内容也是不一样的，需要修改，** 进入到页面之后按 F12 找到 network，在 "name" 列表里找到一项，  在headers 下找到 复制到 代码中的 head={}里，（好像不用head有时候也行）

![img](file:///C:\Users\1\AppData\Roaming\Tencent\Users\1025935864\QQ\WinTemp\RichOle\H$9O{JK1W]0HO00L_SC_ODR.png)



③：在代码的第一层循环中改变数字范围， 比如我是3-2680 到 3-3018， 大致算一下是第几页到第几页， 然后修改循环范围就可以了， 目录下新建两个文件夹 zips ， Origin_json, 一个用来存放下载的压缩包， 一个用来存放爬下来的原始json (因为压缩包里还有另外一段json， 不一样的)。

④运行代码， 控制台会输出在网页上爬下来的json数据， 但是问题就是每隔一段时间代码就会强制断开，出现的

错误是 **requests.exceptions.ChunkedEncodingError·······**  ， 这个不是代码问题， 我在百度上查 有人说是系统后台检测到你的爬虫行为，强制给你断开了。 这样也有几个方案， 第一个是把报错翻到最下面， 找到最后一段并跳转到这个models.py中 ， 这是包自带的文件， 

![img](file:///C:\Users\1\AppData\Roaming\Tencent\Users\1025935864\QQ\WinTemp\RichOle\M71~E%Q8WOZMLZC[SOOL1BJ.png)

找到这三段， 可以适当增大下面两个的数量，比如变成100*1024, 5120，(我这样之后连续跑了十几页，后来又不行了)

这种方法不推荐， 第二种方法 还是在models.py里

找到这个函数,  看下面的todo check后三行

```python
        def generate():
            # Special case for urllib3.
            if hasattr(self.raw, 'stream'):
                try:
                    for chunk in self.raw.stream(chunk_size, decode_content=True):
                        yield chunk
## todo check                        
                except ProtocolError as e:
                    # raise ChunkedEncodingError(e)
                    print(1)
                
                
                except DecodeError as e:
                    raise ContentDecodingError(e)
                except ReadTimeoutError as e:
                    raise ConnectionError(e)
            else:
                # Standard file-like object.
                while True:
                    chunk = self.raw.read(chunk_size)
                    if not chunk:
                        break
                    yield chunk
                    
                    ········
                    ··········
```

， 原始是  **raise ChunkedEncodingError(e)**， 把他注释掉，随便下面输出一个东西 ， 这样做的好处是 ， 不会断掉， 比如我输出的是1， **当输出1 的时候，代表他上面的那条压缩包下载失败了**。 但是json存储下来了，



例如下面的 3， 4， 5个压缩包下载失败了 ，同样其他页面也是， 都是在pycharm终端有输出的， 当代码跑完的时候你可以复制下来 检查一下哪些没下载成功， 然后根据对应的页数去找， 手动下载， 我340多条大概有十几个下载失败的， 手动下也很快的。



```txt
{"文物圖檔編號：": "K1B008519N000000000PAC", "朝代：": "清", "類別：": "陶瓷器", "功能：": "盛裝器", "質材：": "礦物/陶瓷/瓷"}
{"文物圖檔編號：": "K1B008519N000000000PAB", "朝代：": "清", "類別：": "陶瓷器", "功能：": "盛裝器", "質材：": "礦物/陶瓷/瓷"}
{"文物圖檔編號：": "K1B008515N000000000PAD", "朝代：": "清", "類別：": "陶瓷器", "功能：": "盛裝器", "質材：": "礦物/陶瓷/瓷"}
1
{"文物圖檔編號：": "K1B008515N000000000PAC", "朝代：": "清", "類別：": "陶瓷器", "功能：": "盛裝器", "質材：": "礦物/陶瓷/瓷"}
1
{"文物圖檔編號：": "K1B008515N000000000PAB", "朝代：": "清", "類別：": "陶瓷器", "功能：": "盛裝器", "質材：": "礦物/陶瓷/瓷"}
1
{"文物圖檔編號：": "K1B008511N000000000PAF", "朝代：": "清", "類別：": "陶瓷器", "功能：": "盛裝器", "質材：": "礦物/陶瓷/瓷"}
{"文物圖檔編號：": "K1B008511N000000000PAC", "朝代：": "清", "類別：": "陶瓷器", "功能：": "盛裝器", "質材：": "礦物/陶瓷/瓷"}
{"文物圖檔編號：": "K1B008511N000000000PAB", "朝代：": "清", "類別：": "陶瓷器", "功能：": "盛裝器", "質材：": "礦物/陶瓷/瓷"}
{"文物圖檔編號：": "K1B008494N000000000PAG", "朝代：": "清", "類別：": "陶瓷器", "功能：": "盛裝器", "質材：": "礦物/玻璃/"}
第321页采集成功！

```

**建议使用校园网， 这样你可以挂着程序出去玩了**



## 第二步：解压

运行 Decompression_Zip.py 这个文件， 注意以下几点：

**①：主函数中修改你自己的路径。**

**②：一定要确保压缩包都是完整的， 不然程序半路就会报错，前面的就白解压了**

这个程序会把你的当前目录下的zips文件夹内压缩包全部自动解压， **建议先备份所有压缩包到另外一个文件夹中， 出错你就白下载了**





## 第三步：合并json



运行 Merge_Json.py

我的做法是分别检索Origin_Json 以及 zip 下的各个文件， 并且分别把这两个目录下所有的json名全部存储到列表中， 利用嵌套循环遍历两个列表， 当检测到两个列表里有元素相等， 也就是文物编号是同一个的时候，进行合并，分别读取两个文件的内容， 存入列表中， 对于每个文件，第二个列表append在第一个列表后，然后再进行列表中双引号去除，最后转换为字典，存入到zips中相对应的文件夹(名字是文物编号)下。



因为最终每个文件夹要保存图片和json， 压缩包里已经有图片了， 所以把合并后的json覆盖之前压缩包里的json就可以了。

```
{
    "文物圖檔編號：": "  C1B001306N000000000PAD",
    "朝代：": "  清",
    "類別：": "  陶瓷器",
    "功能：": "  陳設器",
    "質材：": "  礦物/陶瓷/",
    "品名": "  清 康熙 青花山水瓶",
    "朝代": "  時代不詳  ",
    "作者": "  ",
    "尺寸": "  高44.7公分 口徑12公分 底徑12公分"
}
```





